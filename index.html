
<!-- Turns out switching styles is just an href but this shows how to use the reveal.js configure() method -->

<!doctype html>
<html lang="en">	
<head>
	<meta charset="utf-8">
	<title>uEA2013 - Speckles</title>
	<!-- On iOS Safari, run in full-screen mode -->
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	

	<!-- Provide basic styles for controls, slides, etc. -->
	<link rel="stylesheet" href="reveal.js/css/reveal.css">
	
	<!-- Give the overall presentation a distinct appearance-->
	<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">

	<!-- For syntax highlighting -->
	<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

	<!-- If the query includes 'print-pdf', use the PDF print sheet -->
	<script>
		document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
	</script>

	<!--Add support for earlier versions of Internet Explorer >
	<!--[if lt IE 9]>
	<script src="reveal.js/lib/js/html5shiv.js"></script>
	<![endif]-->

	<link rel="stylesheet" href="assets/css/main.css">
	
</head>


<body>

	<!-- Wrap the entire slide show in a div using the "reveal" class. -->
	<div class="reveal">
	
		<!-- Wrap all  slides in a div using the "slides" class. -->
		<div class="slides">
		
			<!-- Each slide using a standard HTML
			section tag. -->
			<section id="themes">
				<h1>Un Sistema Digital para Procesar Señales Speckle en Tiempo Real</h1>
				<p>
					<span style="color: #13daec">F. Ferrara</span> -
					<span style="color: #13daec">E. Cozzolino</span> -
					<span style="color: #13daec">E. Todorovich</span> -
					<span style="color: #13daec">M. Vázquez</span>
				</p>
				<p>
					<span style="color: #13daec">G. Bioul</span> -
					<span style="color: #13daec">A. Dai Pra</span> -
					<span style="color: #13daec">I. Passoni</span>
				</p>
				<p>
					<img height="80px" src="assets/img/ufasta.png" alt="logo UFASTA">
					<img height="80px" src="assets/img/unicen.png" alt="logo UNICEN">
					<img height="80px" src="assets/img/unmdp.png" alt="logo UNICEN">
				</p>
			</section>

			<section>
                <h2>Contenido</h2>
                <ul class="fragment">
                    <li>Introducción</li>
                    <li>Marco Teórico</li>
                    <li>Algoritmos</li>
                    <li>Circuitos Digitales</li>
                    <li>Experimentos</li>
                    <li>Conclusiones</li>
                </ul>
            </section>

            <section>

            	<section>
            		<h2>Introducción</h2>
            	</section>

				<section>
					<h3>Speckle</h3>
	                <p>
	                	<span style="color: #2aef44">Fenómeno óptico</span> que se produce cuando una luz láser reflejada desde una superficie iluminada se muestra como un patrón granular de alto contraste.
	                </p>
				</section>

				<section>
					<img src="assets/img/FenomenoOptico.png" alt="Fenómeno Óptico">
				</section>

				<section>
					<h3>Speckle</h3>
	                <p>
	                	Cuando hay algún tipo de actividad en la superficie, el patrón de speckle varia en el tiempo produciendo un <span style="color: #2aef44">fenómeno físico</span> llamado <span style="color: #2aef44">"de ebullición"</span> donde los speckles desaparecen y aparecen sin ningún desplazamiento significativo. La actividad esta dada por el cambio de las propiedades de la muestra.
	                </p>
				</section>

				<section>
					<h3>Speckle</h3>
	                <p>
	                	Este comportamiento puede darse en fenómenos como:
	                </p>
	                <ul class="fragment">
	                	<li>Viabilidad de semillas</li>
	                    <li>Actividad bacteriana</li>
	                    <li>Golpes en frutas</li>
	                    <li>Secado de pintura</li>
	                    <li>Corrosión</li>
	                </ul>
				</section>

				<section>
					<h3>Secuencia de imágenes</h3>
	                <p>
	                	Capturadas por la cámara y procesadas por una computadora de propósito general para <span style="color: #2aef44">caracterizar los fenómenos</span>, utilizando <span style="color: #2aef44">descriptores</span> que analizan el comportamiento de cada pixel.
	                </p>
				</section>

				<section>
					<img src="assets/img/SecuenciaDeImagenes.png" alt="Secuencia de Imagenes">
				</section>

				<section>
					<h3>Fuzzy Granular Descriptor (<span style="color: #2aef44">FGD</span>)</h3>
	                <ul>
	                	<li class="fragment">Mayor eficacia</li>
	                    <li class="fragment">Menor complejidad computacional</li>
	                </ul>
				</section>

				<section>
					<h3>Rough Fuzzy Granular Descriptor (<span style="color: #2aef44">RFGD</span>)</h3>
	                <ul>
	                    <li class="fragment" data-fragment-index="0">Conceptos de teoría de Conjuntos Aproximados</li>
	                    <li class="fragment" data-fragment-index="0">Conceptos de teoría de Conjuntos Difusos</li>
	                    <li class="fragment">Pensado para operar en tiempo real</li>
	                    <li class="fragment">Pensado para sistemas digitales</li>
	                </ul>
				</section>

			</section>

			<section>

				<section>
					<h2>Marco Teórico<h2>
				</section>

				<section>
					<h3>Actividad de la imagen</h3>
					<p>
						Variaciones de intensidad de cada pixel dentro de una secuencia de imágenes en un intervalo dado de tiempo.
					</p>
					<p>
						Se da cuando hay cambios significativos en la intensidad de las señales. La noción de <span style="color: #2aef44">variación de intensidad significativa</span> es difícil de definir. Depende de la aplicación y puede ser subjetiva e incierta.
					</p>
				</section>

				<section>
					<h3>THSP</h3>
					<p>
						La variación de la intensidad de cada pixel a través de la secuencia de imágenes capturadas a intervalos de tiempo fijos determina una señal unidimensional llamada "<span style="color: #2aef44">Historia en el Tiempo del Patrón Speckle</span>".
					</p>
				</section>

				<section>
					<img src="assets/img/IntervalDefinitions.png" alt="Definición de Intervalos">
					<p>
						<small>Definición de intervalos</small>
					</p>
				</section>

				<section>
					<img src="assets/img/GranulesDensity.png" alt="Densidad de Granulos">
					<p>
						<small>Cálculo de densidad de gránulos de una señal arbitraria</small>
					</p>
				</section>

			</section>

			<section>

				<section>
					<h2>Algoritmos</h2>
				</section>

				<section>
					<h3>Diagrama de Flujo</h3>
					<img src="assets/img/Algoritmo01.png" alt="Diagrama de Flujo">
				</section>

				<section>
					<h3>Diagrama de Flujo</h3>
					<img width="550" height="650" src="assets/img/Algoritmo02.png" alt="Diagrama de Flujo">
				</section>

			</section>

			<section>

				<section>
					<h2>Circuitos Digitales</h2>
				</section>

				<section>
					<h3>Calculo Indice de Actividad</h3>
					<img width="550" height="650" src="assets/img/TopLevel.png" alt="Indice de Actividad">
				</section>

				<section>
					<h3>Calculo Indice de Actividad</h3>
					<ul>
	                	<li class="fragment" data-fragment-index="1"><span style="color: #FC6A31">4 Módulos Principales</span></li>
	                    <ul>
		                	<li class="fragment" data-fragment-index="2">Calc_Hist</li>
		                    <li class="fragment" data-fragment-index="2">Calc_Regions</li>
		                    <li class="fragment" data-fragment-index="2">Calc_Granules</li>
		                    <li class="fragment" data-fragment-index="2">Divider</li>
		                </ul>
	                	<li class="fragment" data-fragment-index="3"><span style="color: #FC6A31">3 Memorias Principales</span></li>
	                	<ul>
		                	<li class="fragment" data-fragment-index="4">Mem_Hist</li>
		                    <li class="fragment" data-fragment-index="4">Mem_Count</li>
		                    <li class="fragment" data-fragment-index="4">Mem_Flags</li>
		                </ul>
	                </ul>
				</section>

				<section>
					<h3>Calculo Indice de Actividad</h3>
					<ul>
	                	<li class="fragment" data-fragment-index="1"><span style="color: #2aef44">Señales de Entrada</span></li>
	                	<ul>
		                	<li class="fragment" data-fragment-index="2">start</li>
		                    <li class="fragment" data-fragment-index="2">pxIn</li>
		                    <li class="fragment" data-fragment-index="2">pxInAddr</li>
		                    <li class="fragment" data-fragment-index="2">frIn</li>
		                </ul>
	                    <li class="fragment" data-fragment-index="3"><span style="color: #2aef44">Señales de Salida</span></li>
	                    <ul>
		                	<li class="fragment" data-fragment-index="4">Q</li>
		                    <li class="fragment" data-fragment-index="4">pxOutAddr</li>
		                    <li class="fragment" data-fragment-index="4">frOut</li>
		                </ul>
	                </ul>
				</section>

				<section>
					<h3>Calculo del Histograma</h3>
					<ul>
						<li>Se analiza el primer frame capturado</li>
						<li>Se almacenan los 256 registros binarios en MEM_HIST</li>
						<li>La memoria MEM_HIST se direcciona por la intensidad del pixel [0, 255]</li>
						<li>El numero de pixeles en esta dirección se incrementa en uno</li>
						<li>En el siguiente ciclo se escribe el resultado en el mismo registro</li>
						<li>Se trabaja de manera segmentada siendo MEM_HIST de doble puerto</li>
					</ul>
				</section>

				<section>
					<h3>Calculo de los Limites de las Regiones</h3>
					<img width="800" height="600" src="assets/img/CalcRegions.png" alt="Calculo Limites Regiones">
				</section>

				<section>
					<h3>Calculo de los Limites de las Regiones</h3>
					<p>
						Los siguientes pasos se repiten 2Z-2 veces, siendo Z la cantidad de zonas (3).
					</p>
					<ul>
						<li>Se accede secuencialmente a MEM_HIST</li>
						<li>Se acumula los valores de registros binarios en el registro AccData hasta que supera N<sub>m</sub></li>
						<li>La dirección actual se guarda en el registro <span style="color: #2aef44">Region</span> correspondiente.</li>
					</ul>
				</section>

				<section>
					<h3>Calculo de Gránulos</h3>
					<img src="assets/img/CalcGranules.png" alt="Calculo de Granulos">
				</section>

				<section>
					<h3>Calculo de Gránulos</h3>
					<ul>
						<li>El código de zona, de la imagen anterior, del pixel que entra se lee de MEM_FLAGS</li>
						<li>Se compara el código de zona anterior con el actual</li>
						<li>Si la intensidad cambia a una nueva zona, en el siguiente ciclo de reloj</i>
							<ul>
								<li>Se aumenta el contador del granulo correspondiente en MEM_COUNT</li>
								<li>Se actualiza el código actual de zona en MEM_FLAGS</li>
							</ul>

					</ul>
					<p><br></p>
					<p>
						Independientemente de que haya o no cambio de zona, se continua leyendo los pixeles con normalidad ya que las memorias son de doble puerto
					</p>
				</section>

				<section>
					<h3>Calculo de División</h3>
					<p>
						Se utiliza el algoritmo de división por restauración en punto fijo y se adapta para calcular el <span style="color: #FC6A31">AI<sub>ij</sub></span> por cada pixel en cada nuevo frame.
					</p>
					<p>
						El circuito trabaja en pipeline para poder comenzar el calculo de un nuevo cociente en cada nuevo ciclo de reloj.
					</p>
					<p>
						No se aplica normalización a los operandos, por lo que algunos ceros iniciales se podrían obtener para los cocientes.
					</p>
				</section>

				<section>
					<h3>Calculo de División</h3>
					<ul>
						<li>El indice de actividad se encuentra en [0, 2]</li>
						<li>Con p bits de precisión fraccionaria, se puede utilizar un formato XX.X___X</li>
						<li>Se genera un cociente exacto de la forma X.X___X para los resultados menores a 2</li>
						<li>Se aproxima el cociente a 1.1___1 cuando el cociente es exactamente 2</li>
						<li>La latencia del divisor es de p + 2 ciclos de reloj</li>
						<li>La latencia del calculo de gránulos es de 2 ciclos de reloj</li>
						<li>La latencia del indice de actividad es p + 4 ciclos de reloj</li>
					</ul>
				</section>

			</section>

			<section>

				<section>
					<h2>Experimentos</h2>
				</section>

				<section>
					<div id="tabla1" class="estimacion-tiempos">
		                <table >
		                    <tr>
		                        <td rowspan="2"># Pixeles</td>
		                        <td colspan="3"># Frames</td>
		                    </tr>
		                    <tr>
		                    	<td>Indicadores</td>
		                    	<td>64</td>
		                    	<td>128</td>
		                    </tr>
		                    <tr>
		                    	<td rowspan="5">128 x 128</td>
		                    	<td><strong>t<sub>p</sub></strong> (ns)</td>
		                    	<td>4.02</td>
		                    	<td>4.04</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>t<sub>p,opt</sub></strong> (ns)</td>
		                    	<td>3.48</td>
		                    	<td>3.48</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>#ff</strong></td>
		                    	<td>311</td>
		                    	<td>331</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>#LUT</strong></td>
		                    	<td>377</td>
		                    	<td>398</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>#RAMB</strong></td>
		                    	<td>4 + 3</td>
		                    	<td>5 + 2</td>
		                    </tr>
		                    <tr>
		                    	<td rowspan="5">256 x 256</td>
		                    	<td><strong>t<sub>p</sub></strong> (ns)</td>
		                    	<td>4.86</td>
		                    	<td>4.87</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>t<sub>p,opt</sub></strong> (ns)</td>
		                    	<td>3.52</td>
		                    	<td>3.52</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>#ff</strong></td>
		                    	<td>319</td>
		                    	<td>334</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>#LUT</strong></td>
		                    	<td>397</td>
		                    	<td>416</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>#RAMB</strong></td>
		                    	<td>20 + 1</td>
		                    	<td>22 + 1</td>
		                    </tr>
		                    <tr>
		                    	<td rowspan="5">512 x 512</td>
		                    	<td><strong>t<sub>p</sub></strong> (ns)</td>
		                    	<td>5.42</td>
		                    	<td>5.43</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>t<sub>p,opt</sub></strong> (ns)</td>
		                    	<td>3.52</td>
		                    	<td>3.52</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>#ff</strong></td>
		                    	<td>329</td>
		                    	<td>349</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>#LUT</strong></td>
		                    	<td>404</td>
		                    	<td>423</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>#RAMB</strong></td>
		                    	<td>80 + 1</td>
		                    	<td>88 + 1</td>
		                    </tr>
		                </table>
		            </div>
				</section>

				<section>
					<div id="tabla2" class="potencia-energia">
		                <table >
		                    <tr>
		                        <td rowspan="2"># Pixeles</td>
		                        <td colspan="3"># Frames</td>
		                    </tr>
		                    <tr>
		                    	<td><b>Indicadores</b></td>
		                    	<td><b>64</b></td>
		                    	<td><b>128</b></td>
		                    </tr>
		                    <tr>
		                    	<td rowspan="2"><b>128 x 128</b></td>
		                    	<td><strong>Power</strong> (W)</td>
		                    	<td>1.129</td>
		                    	<td>1.131</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>Energía por pixel</strong> (nJ)</td>
		                    	<td>4.516</td>
		                    	<td>4.524</td>
		                    </tr>
		                    <tr>
		                    	<td rowspan="2"><b>256 x 256</b></td>
		                    	<td><strong>Power</strong> (W)</td>
		                    	<td>1.085</td>
		                    	<td>1.089</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>Energía por pixel</strong> (nJ)</td>
		                    	<td>4.34</td>
		                    	<td>4.356</td>
		                    </tr>
		                    <tr>
		                    	<td rowspan="2"><b>512 x 512</b></td>
		                    	<td><strong>Power</strong> (W)</td>
		                    	<td>1.113</td>
		                    	<td>1.117</td>
		                    </tr>
		                    <tr>
		                    	<td><strong>Energía por pixel</strong> (nJ)</td>
		                    	<td>4.452</td>
		                    	<td>4.468</td>
		                    </tr>
		                </table>
		            </div>
				</section>

				<section>
					<ul>
						<li>FPGA Virtex-6 de Xilinx (xc6vlx130t ff484 -3)</li>
						<li>RAMB36E1 + RAMB18E1</li>
						<li>El análisis de potencia y energía solo incluye el core</li>
						<li>La frecuencia del circuito es de 250 MHz (periodo de 4 ns) para la estimación</li>
						<li>Mayor número de pixeles -> Mayor consumo área / Mayor consumo memoria embebida</li>
						<li>Mayor número de frames -> Mayor consumo área</li>
						
					</ul>
				</section>

				<section>
					<ul>
						<li>El análisis del camino critico permite un compromiso entre el periodo de reloj y la latencia</li>
						<li>Latencia de 12 ciclos de reloj para 8 bits de precisión</li>
						<li><span style="color: #2aef44">1000 fps</span> para frames de 512 x 512</li>
					</ul>
				</section>

			</section>

			<section>

				<section>
					<h2>Conclusiones</h2>
				</section>

				<section>
					<ul>
						<li>El descriptor FGD fue reformulado como RFGD para un circuito digital</li>
						<li>Circuito compuesto por</li>
						<ul>
							<li>1 sumador</li>
							<li>6 comparadores</li>
							<li>1 nivel de logica adicional</li>
							<li>9 restadores</li>
							<li>9 multiplexores</li>
						</ul>
						<li>Diseñado mediante una descripción portable en VHDL</li>
						<li>Realiza el calculo de granulos en tiempo real de señales THSP</li>
						<li>Los mejores resultados son obtenidos si la memoria es implementada en el mismo chip</li>
					</ul>
				</section>

			</section>

			<section>
				<h2>¿Preguntas?</h2>
			</section>

		</div>
	</div>

	<!-- Pesentation Details -->
	<div class="presentation-details">
		<p>
			Speckles &bull; uEA 2013 &bull; F. Ferrara
		</p>
	</div>

	<!-- Speed up scripts; make all style sheets responsive, etc. -->
	<!-- Not part of reveal.js. See http://headjs.com -->
	<script src="reveal.js/lib/js/head.min.js"></script>
	
	<!-- Use a minimized version of reveal.js to speed page loading. -->
	<script src="reveal.js/js/reveal.min.js"></script>

	<script>
		
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
			transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

			// Optional libraries used to extend on reveal.js
			dependencies: [
				{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
				{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				{ src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
			]
		});

	</script>


</body>
</html>